// SPDX-License-Identifier: MITpragma solidity >=0.6.11;import "https://github.com/OpenZeppelin/openzeppelin-contracts/contracts/math/SafeMath.sol";    contract ERC20 {        using SafeMath for uint;        string public name;    string public symbol;    uint private _totalSupply;    uint public decimals;        event Transfer(address indexed from, address indexed to, uint tokens);    event Approval(address indexed tokenOwner, address indexed spender, uint amount);            mapping(address => uint) private balance;    mapping(address => mapping(address => uint)) private allowances;        constructor(string memory _name, string memory _symbol, uint initialSupply) public {        name = _name;        symbol = _symbol;        decimals = 18;        _totalSupply = initialSupply*10**decimals;  //permet de diviser un token en 10**decimals unit√©s        balance[msg.sender] = _totalSupply;    }        function totalSupply() public view returns (uint) {        return _totalSupply;    }        function balanceOf(address tokenOwner) public view returns (uint) {        return balance[tokenOwner];    }        function transfer(address _to, uint _amount) public returns(bool success) {        balance[msg.sender] = balance[msg.sender].sub(_amount);        balance[_to] = balance[_to].add(_amount);        emit Transfer(msg.sender, _to, _amount);        return true;    }        function approve(address _spender, uint _amount) external returns (bool success) {        require(_amount <= balance[msg.sender], "Not enough balance");        allowances[msg.sender][_spender] = _amount;        emit Approval(msg.sender, _spender,_amount);        return true;    }        function allowance(address tokenOwner, address spender) view external returns (uint remaining) {        return allowances[tokenOwner][spender];    }        function transferFrom(address _from, address _to, uint _amount) external returns (bool success) {        require(allowances[_from][msg.sender] >= _amount, "Insuffisant remaining");        require(balance[_from] > _amount, "Not enough funds");        require(_to != address(0), "Invalid address");        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_amount);        balance[_from] = balance[_from].sub(_amount);        balance[_to] = balance[_to].add(_amount);        return true;    }                                    }